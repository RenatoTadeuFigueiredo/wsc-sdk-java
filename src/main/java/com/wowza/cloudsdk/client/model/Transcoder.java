/*
 * This code and all components Â© 2015 - 2019 Wowza Media Systems, LLC. All rights reserved.
 * This code is licensed pursuant to the BSD 3-Clause License.
 * 
 * Wowza Streaming Cloud REST API Reference Documentation
 *
 * OpenAPI spec version: v1.3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.wowza.cloudsdk.client.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.HashMap;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import com.wowza.cloudsdk.client.model.Output;
import com.wowza.cloudsdk.client.model.PlaybackUrl;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.time.OffsetDateTime;

/**
 * 
 */
@ApiModel(description = "")
@javax.annotation.Generated(value ="com.wowza.cloudsdk.JavaCreate", date = "2019-03-02T10:45:24.077Z")
public class Transcoder {
  @SerializedName("application_name")
  private String applicationName = null;

  /**
   * The billing mode for the transcoder. The default is &lt;strong&gt;pay_as_you_go&lt;/strong&gt;.
   */
  @JsonAdapter(BillingModeEnum.Adapter.class)
  public enum BillingModeEnum {
    PAY_AS_YOU_GO("pay_as_you_go"),
    
    TWENTYFOUR_SEVEN("twentyfour_seven");

    private String value;

    BillingModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BillingModeEnum fromValue(String text) {
      for (BillingModeEnum b : BillingModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<BillingModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BillingModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BillingModeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return BillingModeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("billing_mode")
  private BillingModeEnum billingMode = null;

  /**
   * The location where Wowza Streaming Cloud transcodes your stream. Choose a location as close as possible to your video source.
   */
  @JsonAdapter(BroadcastLocationEnum.Adapter.class)
  public enum BroadcastLocationEnum {
    ASIA_PACIFIC_AUSTRALIA("asia_pacific_australia"),
    
    ASIA_PACIFIC_JAPAN("asia_pacific_japan"),
    
    ASIA_PACIFIC_SINGAPORE("asia_pacific_singapore"),
    
    ASIA_PACIFIC_TAIWAN("asia_pacific_taiwan"),
    
    EU_BELGIUM("eu_belgium"),
    
    EU_GERMANY("eu_germany"),
    
    EU_IRELAND("eu_ireland"),
    
    SOUTH_AMERICA_BRAZIL("south_america_brazil"),
    
    US_CENTRAL_IOWA("us_central_iowa"),
    
    US_EAST_VIRGINIA("us_east_virginia"),
    
    US_WEST_CALIFORNIA("us_west_california"),
    
    US_WEST_OREGON("us_west_oregon");

    private String value;

    BroadcastLocationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BroadcastLocationEnum fromValue(String text) {
      for (BroadcastLocationEnum b : BroadcastLocationEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<BroadcastLocationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BroadcastLocationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BroadcastLocationEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return BroadcastLocationEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("broadcast_location")
  private BroadcastLocationEnum broadcastLocation = null;

  /**
   * The size, in milliseconds, of the incoming buffer. &lt;strong&gt;0&lt;/strong&gt; means no buffer. The default is &lt;strong&gt;4000&lt;/strong&gt; (4 seconds).
   */
  @JsonAdapter(BufferSizeEnum.Adapter.class)
  public enum BufferSizeEnum {
    NUMBER_0(0),
    
    NUMBER_1000(1000),
    
    NUMBER_2000(2000),
    
    NUMBER_3000(3000),
    
    NUMBER_4000(4000),
    
    NUMBER_5000(5000),
    
    NUMBER_6000(6000),
    
    NUMBER_7000(7000),
    
    NUMBER_8000(8000);

    private Integer value;

    BufferSizeEnum(Integer value) {
      this.value = value;
    }

    public Integer getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BufferSizeEnum fromValue(String text) {
      for (BufferSizeEnum b : BufferSizeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<BufferSizeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BufferSizeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BufferSizeEnum read(final JsonReader jsonReader) throws IOException {
        Integer value = jsonReader.nextInt();
        return BufferSizeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("buffer_size")
  private BufferSizeEnum bufferSize = null;

  /**
   * The type of closed caption data being passed from the source. The default, &lt;strong&gt;none&lt;/strong&gt;, indicates that no data is being provided. &lt;strong&gt;cea&lt;/strong&gt; indicates that a CEA closed captioning data stream is being provided. &lt;strong&gt;on_text&lt;/strong&gt; indicates that an onTextData closed captioning data stream is being provided. &lt;strong&gt;both&lt;/strong&gt; indicates that both CEA and onTextData closed captioning data streams are being provided.
   */
  @JsonAdapter(ClosedCaptionTypeEnum.Adapter.class)
  public enum ClosedCaptionTypeEnum {
    NONE("none"),
    
    CEA("cea"),
    
    ON_TEXT("on_text"),
    
    BOTH("both");

    private String value;

    ClosedCaptionTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ClosedCaptionTypeEnum fromValue(String text) {
      for (ClosedCaptionTypeEnum b : ClosedCaptionTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ClosedCaptionTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ClosedCaptionTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ClosedCaptionTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ClosedCaptionTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("closed_caption_type")
  private ClosedCaptionTypeEnum closedCaptionType = null;

  @SerializedName("created_at")
  private OffsetDateTime createdAt = null;

  /**
   * The type of connection between the source encoder and the transcoder. The default, &lt;strong&gt;pull&lt;/strong&gt;, instructs the transcoder to pull the video from the source. &lt;strong&gt;push&lt;/strong&gt; instructs the source to push the stream to the transcoder. &lt;strong&gt;cdn&lt;/strong&gt; uses a stream source to deliver the stream to the transcoder.
   */
  @JsonAdapter(DeliveryMethodEnum.Adapter.class)
  public enum DeliveryMethodEnum {
    PULL("pull"),
    
    CDN("cdn"),
    
    PUSH("push");

    private String value;

    DeliveryMethodEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DeliveryMethodEnum fromValue(String text) {
      for (DeliveryMethodEnum b : DeliveryMethodEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<DeliveryMethodEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DeliveryMethodEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DeliveryMethodEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return DeliveryMethodEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("delivery_method")
  private DeliveryMethodEnum deliveryMethod = null;

  @SerializedName("delivery_protocols")
  private List<String> deliveryProtocols = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("direct_playback_urls")
  private HashMap<String,List<PlaybackUrl>> directPlaybackUrls = null;

  @SerializedName("disable_authentication")
  private Boolean disableAuthentication = null;

  @SerializedName("domain_name")
  private String domainName = null;

  @SerializedName("id")
  private String id = null;

  @SerializedName("idle_timeout")
  private Integer idleTimeout = null;

  @SerializedName("low_latency")
  private Boolean lowLatency = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("outputs")
  private List<Output> outputs = null;

  @SerializedName("password")
  private String password = null;

  /**
   * The number of users who are allowed to connect directly to the transcoder.
   */
  @JsonAdapter(PlayMaximumConnectionsEnum.Adapter.class)
  public enum PlayMaximumConnectionsEnum {
    NUMBER_10(10),
    
    NUMBER_11(11),
    
    NUMBER_12(12),
    
    NUMBER_13(13),
    
    NUMBER_14(14),
    
    NUMBER_15(15),
    
    NUMBER_16(16),
    
    NUMBER_17(17),
    
    NUMBER_18(18),
    
    NUMBER_19(19),
    
    NUMBER_20(20),
    
    NUMBER_21(21),
    
    NUMBER_22(22),
    
    NUMBER_23(23),
    
    NUMBER_24(24),
    
    NUMBER_25(25),
    
    NUMBER_26(26),
    
    NUMBER_27(27),
    
    NUMBER_28(28),
    
    NUMBER_29(29),
    
    NUMBER_30(30),
    
    NUMBER_31(31),
    
    NUMBER_32(32),
    
    NUMBER_33(33),
    
    NUMBER_34(34),
    
    NUMBER_35(35),
    
    NUMBER_36(36),
    
    NUMBER_37(37),
    
    NUMBER_38(38),
    
    NUMBER_39(39),
    
    NUMBER_40(40),
    
    NUMBER_41(41),
    
    NUMBER_42(42),
    
    NUMBER_43(43),
    
    NUMBER_44(44),
    
    NUMBER_45(45),
    
    NUMBER_46(46),
    
    NUMBER_47(47),
    
    NUMBER_48(48),
    
    NUMBER_49(49),
    
    NUMBER_50(50),
    
    NUMBER_51(51),
    
    NUMBER_52(52),
    
    NUMBER_53(53),
    
    NUMBER_54(54),
    
    NUMBER_55(55),
    
    NUMBER_56(56),
    
    NUMBER_57(57),
    
    NUMBER_58(58),
    
    NUMBER_59(59),
    
    NUMBER_60(60),
    
    NUMBER_61(61),
    
    NUMBER_62(62),
    
    NUMBER_63(63),
    
    NUMBER_64(64),
    
    NUMBER_65(65),
    
    NUMBER_66(66),
    
    NUMBER_67(67),
    
    NUMBER_68(68),
    
    NUMBER_69(69),
    
    NUMBER_70(70),
    
    NUMBER_71(71),
    
    NUMBER_72(72),
    
    NUMBER_73(73),
    
    NUMBER_74(74),
    
    NUMBER_75(75),
    
    NUMBER_76(76),
    
    NUMBER_77(77),
    
    NUMBER_78(78),
    
    NUMBER_79(79),
    
    NUMBER_80(80),
    
    NUMBER_81(81),
    
    NUMBER_82(82),
    
    NUMBER_83(83),
    
    NUMBER_84(84),
    
    NUMBER_85(85),
    
    NUMBER_86(86),
    
    NUMBER_87(87),
    
    NUMBER_88(88),
    
    NUMBER_89(89),
    
    NUMBER_90(90),
    
    NUMBER_91(91),
    
    NUMBER_92(92),
    
    NUMBER_93(93),
    
    NUMBER_94(94),
    
    NUMBER_95(95),
    
    NUMBER_96(96),
    
    NUMBER_97(97),
    
    NUMBER_98(98),
    
    NUMBER_99(99),
    
    NUMBER_100(100);

    private Integer value;

    PlayMaximumConnectionsEnum(Integer value) {
      this.value = value;
    }

    public Integer getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PlayMaximumConnectionsEnum fromValue(String text) {
      for (PlayMaximumConnectionsEnum b : PlayMaximumConnectionsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<PlayMaximumConnectionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PlayMaximumConnectionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PlayMaximumConnectionsEnum read(final JsonReader jsonReader) throws IOException {
        Integer value = jsonReader.nextInt();
        return PlayMaximumConnectionsEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("play_maximum_connections")
  private PlayMaximumConnectionsEnum playMaximumConnections = null;

  /**
   * The transport protocol for the source video. The default is &lt;strong&gt;rtmp&lt;/strong&gt;.
   */
  @JsonAdapter(ProtocolEnum.Adapter.class)
  public enum ProtocolEnum {
    RTMP("rtmp"),
    
    RTSP("rtsp");

    private String value;

    ProtocolEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProtocolEnum fromValue(String text) {
      for (ProtocolEnum b : ProtocolEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ProtocolEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProtocolEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProtocolEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ProtocolEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("protocol")
  private ProtocolEnum protocol = null;

  @SerializedName("recording")
  private Boolean recording = null;

  @SerializedName("source_port")
  private Integer sourcePort = null;

  @SerializedName("source_url")
  private String sourceUrl = null;

  @SerializedName("stream_extension")
  private String streamExtension = null;

  @SerializedName("stream_name")
  private String streamName = null;

  @SerializedName("stream_smoother")
  private Boolean streamSmoother = null;

  @SerializedName("stream_source_id")
  private String streamSourceId = null;

  @SerializedName("suppress_stream_target_start")
  private Boolean suppressStreamTargetStart = null;

  /**
   * The type of transcoder, either &lt;strong&gt;transcoded&lt;/strong&gt; for streams that are transcoded into adaptive bitrate renditions or &lt;strong&gt;passthrough&lt;/strong&gt; for streams that aren&#39;t processed by the transcoder. The default is &lt;strong&gt;transcoded&lt;/strong&gt;.
   */
  @JsonAdapter(TranscoderTypeEnum.Adapter.class)
  public enum TranscoderTypeEnum {
    TRANSCODED("transcoded"),
    
    PASSTHROUGH("passthrough");

    private String value;

    TranscoderTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TranscoderTypeEnum fromValue(String text) {
      for (TranscoderTypeEnum b : TranscoderTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<TranscoderTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TranscoderTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TranscoderTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TranscoderTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("transcoder_type")
  private TranscoderTypeEnum transcoderType = null;

  @SerializedName("updated_at")
  private OffsetDateTime updatedAt = null;

  @SerializedName("username")
  private String username = null;

  @SerializedName("watermark")
  private Boolean watermark = null;

  @SerializedName("watermark_height")
  private Integer watermarkHeight = null;

  @SerializedName("watermark_image_url")
  private String watermarkImageUrl = null;

  /**
   * The opacity, or percentage of transparency, of the watermark. &lt;strong&gt;0&lt;/strong&gt; is fully transparent; &lt;strong&gt;100&lt;/strong&gt; is fully opaque.
   */
  @JsonAdapter(WatermarkOpacityEnum.Adapter.class)
  public enum WatermarkOpacityEnum {
    NUMBER_0(0),
    
    NUMBER_1(1),
    
    NUMBER_2(2),
    
    NUMBER_3(3),
    
    NUMBER_4(4),
    
    NUMBER_5(5),
    
    NUMBER_6(6),
    
    NUMBER_7(7),
    
    NUMBER_8(8),
    
    NUMBER_9(9),
    
    NUMBER_10(10),
    
    NUMBER_11(11),
    
    NUMBER_12(12),
    
    NUMBER_13(13),
    
    NUMBER_14(14),
    
    NUMBER_15(15),
    
    NUMBER_16(16),
    
    NUMBER_17(17),
    
    NUMBER_18(18),
    
    NUMBER_19(19),
    
    NUMBER_20(20),
    
    NUMBER_21(21),
    
    NUMBER_22(22),
    
    NUMBER_23(23),
    
    NUMBER_24(24),
    
    NUMBER_25(25),
    
    NUMBER_26(26),
    
    NUMBER_27(27),
    
    NUMBER_28(28),
    
    NUMBER_29(29),
    
    NUMBER_30(30),
    
    NUMBER_31(31),
    
    NUMBER_32(32),
    
    NUMBER_33(33),
    
    NUMBER_34(34),
    
    NUMBER_35(35),
    
    NUMBER_36(36),
    
    NUMBER_37(37),
    
    NUMBER_38(38),
    
    NUMBER_39(39),
    
    NUMBER_40(40),
    
    NUMBER_41(41),
    
    NUMBER_42(42),
    
    NUMBER_43(43),
    
    NUMBER_44(44),
    
    NUMBER_45(45),
    
    NUMBER_46(46),
    
    NUMBER_47(47),
    
    NUMBER_48(48),
    
    NUMBER_49(49),
    
    NUMBER_50(50),
    
    NUMBER_51(51),
    
    NUMBER_52(52),
    
    NUMBER_53(53),
    
    NUMBER_54(54),
    
    NUMBER_55(55),
    
    NUMBER_56(56),
    
    NUMBER_57(57),
    
    NUMBER_58(58),
    
    NUMBER_59(59),
    
    NUMBER_60(60),
    
    NUMBER_61(61),
    
    NUMBER_62(62),
    
    NUMBER_63(63),
    
    NUMBER_64(64),
    
    NUMBER_65(65),
    
    NUMBER_66(66),
    
    NUMBER_67(67),
    
    NUMBER_68(68),
    
    NUMBER_69(69),
    
    NUMBER_70(70),
    
    NUMBER_71(71),
    
    NUMBER_72(72),
    
    NUMBER_73(73),
    
    NUMBER_74(74),
    
    NUMBER_75(75),
    
    NUMBER_76(76),
    
    NUMBER_77(77),
    
    NUMBER_78(78),
    
    NUMBER_79(79),
    
    NUMBER_80(80),
    
    NUMBER_81(81),
    
    NUMBER_82(82),
    
    NUMBER_83(83),
    
    NUMBER_84(84),
    
    NUMBER_85(85),
    
    NUMBER_86(86),
    
    NUMBER_87(87),
    
    NUMBER_88(88),
    
    NUMBER_89(89),
    
    NUMBER_90(90),
    
    NUMBER_91(91),
    
    NUMBER_92(92),
    
    NUMBER_93(93),
    
    NUMBER_94(94),
    
    NUMBER_95(95),
    
    NUMBER_96(96),
    
    NUMBER_97(97),
    
    NUMBER_98(98),
    
    NUMBER_99(99),
    
    NUMBER_100(100);

    private Integer value;

    WatermarkOpacityEnum(Integer value) {
      this.value = value;
    }

    public Integer getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static WatermarkOpacityEnum fromValue(String text) {
      for (WatermarkOpacityEnum b : WatermarkOpacityEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<WatermarkOpacityEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final WatermarkOpacityEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public WatermarkOpacityEnum read(final JsonReader jsonReader) throws IOException {
        Integer value = jsonReader.nextInt();
        return WatermarkOpacityEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("watermark_opacity")
  private WatermarkOpacityEnum watermarkOpacity = null;

  /**
   * The corner of the video frame in which you want the watermark to appear. The default is &lt;strong&gt;top-left&lt;/strong&gt;.
   */
  @JsonAdapter(WatermarkPositionEnum.Adapter.class)
  public enum WatermarkPositionEnum {
    TOP_LEFT("top-left"),
    
    TOP_RIGHT("top-right"),
    
    BOTTOM_LEFT("bottom-left"),
    
    BOTTOM_RIGHT("bottom-right");

    private String value;

    WatermarkPositionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static WatermarkPositionEnum fromValue(String text) {
      for (WatermarkPositionEnum b : WatermarkPositionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<WatermarkPositionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final WatermarkPositionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public WatermarkPositionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return WatermarkPositionEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("watermark_position")
  private WatermarkPositionEnum watermarkPosition = null;

  @SerializedName("watermark_width")
  private Integer watermarkWidth = null;

  public Transcoder applicationName(String applicationName) {
    this.applicationName = applicationName;
    return this;
  }

   /**
   * The application name from the pull stream source URL.
   * @return applicationName
  **/
  @ApiModelProperty(example = "", value = "The application name from the pull stream source URL.")
  public String getApplicationName() {
    return applicationName;
  }

  public void setApplicationName(String applicationName) {
    this.applicationName = applicationName;
  }

  public Transcoder billingMode(BillingModeEnum billingMode) {
    this.billingMode = billingMode;
    return this;
  }

   /**
   * The billing mode for the transcoder. The default is &lt;strong&gt;pay_as_you_go&lt;/strong&gt;.
   * @return billingMode
  **/
  @ApiModelProperty(example = "", value = "The billing mode for the transcoder. The default is <strong>pay_as_you_go</strong>.")
  public BillingModeEnum getBillingMode() {
    return billingMode;
  }

  public void setBillingMode(BillingModeEnum billingMode) {
    this.billingMode = billingMode;
  }

  public Transcoder broadcastLocation(BroadcastLocationEnum broadcastLocation) {
    this.broadcastLocation = broadcastLocation;
    return this;
  }

   /**
   * The location where Wowza Streaming Cloud transcodes your stream. Choose a location as close as possible to your video source.
   * @return broadcastLocation
  **/
  @ApiModelProperty(example = "", value = "The location where Wowza Streaming Cloud transcodes your stream. Choose a location as close as possible to your video source.")
  public BroadcastLocationEnum getBroadcastLocation() {
    return broadcastLocation;
  }

  public void setBroadcastLocation(BroadcastLocationEnum broadcastLocation) {
    this.broadcastLocation = broadcastLocation;
  }

  public Transcoder bufferSize(BufferSizeEnum bufferSize) {
    this.bufferSize = bufferSize;
    return this;
  }

   /**
   * The size, in milliseconds, of the incoming buffer. &lt;strong&gt;0&lt;/strong&gt; means no buffer. The default is &lt;strong&gt;4000&lt;/strong&gt; (4 seconds).
   * @return bufferSize
  **/
  @ApiModelProperty(example = "", value = "The size, in milliseconds, of the incoming buffer. <strong>0</strong> means no buffer. The default is <strong>4000</strong> (4 seconds).")
  public BufferSizeEnum getBufferSize() {
    return bufferSize;
  }

  public void setBufferSize(BufferSizeEnum bufferSize) {
    this.bufferSize = bufferSize;
  }

  public Transcoder closedCaptionType(ClosedCaptionTypeEnum closedCaptionType) {
    this.closedCaptionType = closedCaptionType;
    return this;
  }

   /**
   * The type of closed caption data being passed from the source. The default, &lt;strong&gt;none&lt;/strong&gt;, indicates that no data is being provided. &lt;strong&gt;cea&lt;/strong&gt; indicates that a CEA closed captioning data stream is being provided. &lt;strong&gt;on_text&lt;/strong&gt; indicates that an onTextData closed captioning data stream is being provided. &lt;strong&gt;both&lt;/strong&gt; indicates that both CEA and onTextData closed captioning data streams are being provided.
   * @return closedCaptionType
  **/
  @ApiModelProperty(example = "", value = "The type of closed caption data being passed from the source. The default, <strong>none</strong>, indicates that no data is being provided. <strong>cea</strong> indicates that a CEA closed captioning data stream is being provided. <strong>on_text</strong> indicates that an onTextData closed captioning data stream is being provided. <strong>both</strong> indicates that both CEA and onTextData closed captioning data streams are being provided.")
  public ClosedCaptionTypeEnum getClosedCaptionType() {
    return closedCaptionType;
  }

  public void setClosedCaptionType(ClosedCaptionTypeEnum closedCaptionType) {
    this.closedCaptionType = closedCaptionType;
  }

  public Transcoder createdAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
    return this;
  }

   /**
   * The date and time that the transcoder was created.
   * @return createdAt
  **/
  @ApiModelProperty(example = "", value = "The date and time that the transcoder was created.")
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }

  public Transcoder deliveryMethod(DeliveryMethodEnum deliveryMethod) {
    this.deliveryMethod = deliveryMethod;
    return this;
  }

   /**
   * The type of connection between the source encoder and the transcoder. The default, &lt;strong&gt;pull&lt;/strong&gt;, instructs the transcoder to pull the video from the source. &lt;strong&gt;push&lt;/strong&gt; instructs the source to push the stream to the transcoder. &lt;strong&gt;cdn&lt;/strong&gt; uses a stream source to deliver the stream to the transcoder.
   * @return deliveryMethod
  **/
  @ApiModelProperty(example = "", value = "The type of connection between the source encoder and the transcoder. The default, <strong>pull</strong>, instructs the transcoder to pull the video from the source. <strong>push</strong> instructs the source to push the stream to the transcoder. <strong>cdn</strong> uses a stream source to deliver the stream to the transcoder.")
  public DeliveryMethodEnum getDeliveryMethod() {
    return deliveryMethod;
  }

  public void setDeliveryMethod(DeliveryMethodEnum deliveryMethod) {
    this.deliveryMethod = deliveryMethod;
  }

  public Transcoder deliveryProtocols(List<String> deliveryProtocols) {
    this.deliveryProtocols = deliveryProtocols;
    return this;
  }

  public Transcoder addDeliveryProtocolsItem(String deliveryProtocolsItem) {
    if (this.deliveryProtocols == null) {
      this.deliveryProtocols = new ArrayList<String>();
    }
    this.deliveryProtocols.add(deliveryProtocolsItem);
    return this;
  }

   /**
   * An array of playback protocols enabled for this transcoder. By default, &lt;strong&gt;rtmp&lt;/strong&gt;, &lt;strong&gt;rtsp&lt;/strong&gt;, and &lt;strong&gt;wowz&lt;/strong&gt; are returned.
   * @return deliveryProtocols
  **/
  @ApiModelProperty(example = "\"\"", value = "An array of playback protocols enabled for this transcoder. By default, <strong>rtmp</strong>, <strong>rtsp</strong>, and <strong>wowz</strong> are returned.")
  public List<String> getDeliveryProtocols() {
    return deliveryProtocols;
  }

  public void setDeliveryProtocols(List<String> deliveryProtocols) {
    this.deliveryProtocols = deliveryProtocols;
  }

  public Transcoder description(String description) {
    this.description = description;
    return this;
  }

   /**
   * An optional description of the transcoder.
   * @return description
  **/
  @ApiModelProperty(example = "", value = "An optional description of the transcoder.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public Transcoder directPlaybackUrls(HashMap<String,List<PlaybackUrl>> directPlaybackUrls) {
    this.directPlaybackUrls = directPlaybackUrls;
    return this;
  }

  public Transcoder addDirectPlaybackUrlsItem(PlaybackUrl directPlaybackUrlsItem) {
    if (this.directPlaybackUrls == null) {
      this.directPlaybackUrls = new HashMap<String,List<PlaybackUrl>>();
    }
        if ( !this.directPlaybackUrls.containsKey(name) )
                {
                List<PlaybackUrl> newList = new ArrayList<PlaybackUrl>();
                newList.add(directPlaybackUrlsItem);
                this.directPlaybackUrls.put(name,newList);
                }
        else
                {
                List<PlaybackUrl> current = this.directPlaybackUrls.get(name);
                current.add(directPlaybackUrlsItem);
                this.directPlaybackUrls.put(name,current);
                }
    return this;
  }

   /**
   * An array of direct playback URLs the transcoder&#39;s delivery protocols. Each protocol has a URL for the source and a URL for each output rendition.
   * @return directPlaybackUrls
  **/
  @ApiModelProperty(example = "\"\"", value = "An array of direct playback URLs the transcoder's delivery protocols. Each protocol has a URL for the source and a URL for each output rendition.")
  public HashMap<String,List<PlaybackUrl>> getDirectPlaybackUrls() {
    return directPlaybackUrls;
  }

  public void setDirectPlaybackUrls(HashMap<String,List<PlaybackUrl>> directPlaybackUrls) {
    this.directPlaybackUrls = directPlaybackUrls;
  }

  public Transcoder disableAuthentication(Boolean disableAuthentication) {
    this.disableAuthentication = disableAuthentication;
    return this;
  }

   /**
   * Authentication is required by default for RTMP and RTSP push connections from a video source to the transcoder. Specify &lt;strong&gt;true&lt;/strong&gt; to disable authentication with the video source.
   * @return disableAuthentication
  **/
  @ApiModelProperty(value = "Authentication is required by default for RTMP and RTSP push connections from a video source to the transcoder. Specify <strong>true</strong> to disable authentication with the video source.")
  public Boolean isDisableAuthentication() {
    return disableAuthentication;
  }

  public void setDisableAuthentication(Boolean disableAuthentication) {
    this.disableAuthentication = disableAuthentication;
  }

  public Transcoder domainName(String domainName) {
    this.domainName = domainName;
    return this;
  }

   /**
   * The domain name from the pull stream source URL.
   * @return domainName
  **/
  @ApiModelProperty(example = "", value = "The domain name from the pull stream source URL.")
  public String getDomainName() {
    return domainName;
  }

  public void setDomainName(String domainName) {
    this.domainName = domainName;
  }

  public Transcoder id(String id) {
    this.id = id;
    return this;
  }

   /**
   * The unique alphanumeric string that identifies the transcoder.
   * @return id
  **/
  @ApiModelProperty(example = "", value = "The unique alphanumeric string that identifies the transcoder.")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public Transcoder idleTimeout(Integer idleTimeout) {
    this.idleTimeout = idleTimeout;
    return this;
  }

   /**
   * The amount of idle time, in seconds, before the transcoder automatically shuts down. Valid values are the integers &lt;strong&gt;0&lt;/strong&gt; (never shuts down) to &lt;strong&gt;172800&lt;/strong&gt; (48 hours). The default is &lt;strong&gt;1200&lt;/strong&gt; (20 minutes).
   * @return idleTimeout
  **/
  @ApiModelProperty(example = "", value = "The amount of idle time, in seconds, before the transcoder automatically shuts down. Valid values are the integers <strong>0</strong> (never shuts down) to <strong>172800</strong> (48 hours). The default is <strong>1200</strong> (20 minutes).")
  public Integer getIdleTimeout() {
    return idleTimeout;
  }

  public void setIdleTimeout(Integer idleTimeout) {
    this.idleTimeout = idleTimeout;
  }

  public Transcoder lowLatency(Boolean lowLatency) {
    this.lowLatency = lowLatency;
    return this;
  }

   /**
   * If &lt;strong&gt;true&lt;/strong&gt;, turns off the sort packet buffer and speeds the time it takes to decode and deliver video data to the player. The default is &lt;strong&gt;false&lt;/strong&gt;.
   * @return lowLatency
  **/
  @ApiModelProperty(value = "If <strong>true</strong>, turns off the sort packet buffer and speeds the time it takes to decode and deliver video data to the player. The default is <strong>false</strong>.")
  public Boolean isLowLatency() {
    return lowLatency;
  }

  public void setLowLatency(Boolean lowLatency) {
    this.lowLatency = lowLatency;
  }

  public Transcoder name(String name) {
    this.name = name;
    return this;
  }

   /**
   * A descriptive name for the transcoder. Maximum 200 characters.
   * @return name
  **/
  @ApiModelProperty(example = "", value = "A descriptive name for the transcoder. Maximum 200 characters.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Transcoder outputs(List<Output> outputs) {
    this.outputs = outputs;
    return this;
  }

  public Transcoder addOutputsItem(Output outputsItem) {
    if (this.outputs == null) {
      this.outputs = new ArrayList<Output>();
    }
    this.outputs.add(outputsItem);
    return this;
  }

   /**
   * Output renditions associated with the transcoder.
   * @return outputs
  **/
  @ApiModelProperty(value = "Output renditions associated with the transcoder.")
  public List<Output> getOutputs() {
    return outputs;
  }

  public void setOutputs(List<Output> outputs) {
    this.outputs = outputs;
  }

  public Transcoder password(String password) {
    this.password = password;
    return this;
  }

   /**
   * A password for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
   * @return password
  **/
  @ApiModelProperty(example = "", value = "A password for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public Transcoder playMaximumConnections(PlayMaximumConnectionsEnum playMaximumConnections) {
    this.playMaximumConnections = playMaximumConnections;
    return this;
  }

   /**
   * The number of users who are allowed to connect directly to the transcoder.
   * @return playMaximumConnections
  **/
  @ApiModelProperty(example = "", value = "The number of users who are allowed to connect directly to the transcoder.")
  public PlayMaximumConnectionsEnum getPlayMaximumConnections() {
    return playMaximumConnections;
  }

  public void setPlayMaximumConnections(PlayMaximumConnectionsEnum playMaximumConnections) {
    this.playMaximumConnections = playMaximumConnections;
  }

  public Transcoder protocol(ProtocolEnum protocol) {
    this.protocol = protocol;
    return this;
  }

   /**
   * The transport protocol for the source video. The default is &lt;strong&gt;rtmp&lt;/strong&gt;.
   * @return protocol
  **/
  @ApiModelProperty(example = "", value = "The transport protocol for the source video. The default is <strong>rtmp</strong>.")
  public ProtocolEnum getProtocol() {
    return protocol;
  }

  public void setProtocol(ProtocolEnum protocol) {
    this.protocol = protocol;
  }

  public Transcoder recording(Boolean recording) {
    this.recording = recording;
    return this;
  }

   /**
   * If &lt;strong&gt;true&lt;/strong&gt;, creates a recording of the transcoded output. The default is &lt;strong&gt;false&lt;/strong&gt;.
   * @return recording
  **/
  @ApiModelProperty(value = "If <strong>true</strong>, creates a recording of the transcoded output. The default is <strong>false</strong>.")
  public Boolean isRecording() {
    return recording;
  }

  public void setRecording(Boolean recording) {
    this.recording = recording;
  }

  public Transcoder sourcePort(Integer sourcePort) {
    this.sourcePort = sourcePort;
    return this;
  }

   /**
   * The port used for RTMP pull connections to Wowza Streaming Cloud.
   * @return sourcePort
  **/
  @ApiModelProperty(example = "", value = "The port used for RTMP pull connections to Wowza Streaming Cloud.")
  public Integer getSourcePort() {
    return sourcePort;
  }

  public void setSourcePort(Integer sourcePort) {
    this.sourcePort = sourcePort;
  }

  public Transcoder sourceUrl(String sourceUrl) {
    this.sourceUrl = sourceUrl;
    return this;
  }

   /**
   * For the &lt;em&gt;delivery_method&lt;/em&gt; &lt;strong&gt;pull&lt;/strong&gt;. Enter the source&#39;s web address without the preceding protocol or the trailing slash (/).
   * @return sourceUrl
  **/
  @ApiModelProperty(example = "", value = "For the <em>delivery_method</em> <strong>pull</strong>. Enter the source's web address without the preceding protocol or the trailing slash (/).")
  public String getSourceUrl() {
    return sourceUrl;
  }

  public void setSourceUrl(String sourceUrl) {
    this.sourceUrl = sourceUrl;
  }

  public Transcoder streamExtension(String streamExtension) {
    this.streamExtension = streamExtension;
    return this;
  }

   /**
   * For the &lt;em&gt;delivery_method&lt;/em&gt; &lt;strong&gt;push&lt;/strong&gt;. Some encoders append an extension to their stream names. If the device you&#39;re using does this, enter the extension.
   * @return streamExtension
  **/
  @ApiModelProperty(example = "", value = "For the <em>delivery_method</em> <strong>push</strong>. Some encoders append an extension to their stream names. If the device you're using does this, enter the extension.")
  public String getStreamExtension() {
    return streamExtension;
  }

  public void setStreamExtension(String streamExtension) {
    this.streamExtension = streamExtension;
  }

  public Transcoder streamName(String streamName) {
    this.streamName = streamName;
    return this;
  }

   /**
   * The stream name from the pull stream source URL.
   * @return streamName
  **/
  @ApiModelProperty(example = "", value = "The stream name from the pull stream source URL.")
  public String getStreamName() {
    return streamName;
  }

  public void setStreamName(String streamName) {
    this.streamName = streamName;
  }

  public Transcoder streamSmoother(Boolean streamSmoother) {
    this.streamSmoother = streamSmoother;
    return this;
  }

   /**
   * A dynamic buffer that helps stabilize streams in rough network conditions, but adds latency. Specify &lt;strong&gt;true&lt;/strong&gt; to enable stream smoothing. The default is &lt;strong&gt;false&lt;/strong&gt;.
   * @return streamSmoother
  **/
  @ApiModelProperty(value = "A dynamic buffer that helps stabilize streams in rough network conditions, but adds latency. Specify <strong>true</strong> to enable stream smoothing. The default is <strong>false</strong>.")
  public Boolean isStreamSmoother() {
    return streamSmoother;
  }

  public void setStreamSmoother(Boolean streamSmoother) {
    this.streamSmoother = streamSmoother;
  }

  public Transcoder streamSourceId(String streamSourceId) {
    this.streamSourceId = streamSourceId;
    return this;
  }

   /**
   * For the &lt;em&gt;delivery_method&lt;/em&gt; &lt;strong&gt;cdn&lt;/strong&gt;. The alphanumeric string that identifies the stream source that you want to use to deliver the stream to the transcoder.
   * @return streamSourceId
  **/
  @ApiModelProperty(example = "", value = "For the <em>delivery_method</em> <strong>cdn</strong>. The alphanumeric string that identifies the stream source that you want to use to deliver the stream to the transcoder.")
  public String getStreamSourceId() {
    return streamSourceId;
  }

  public void setStreamSourceId(String streamSourceId) {
    this.streamSourceId = streamSourceId;
  }

  public Transcoder suppressStreamTargetStart(Boolean suppressStreamTargetStart) {
    this.suppressStreamTargetStart = suppressStreamTargetStart;
    return this;
  }

   /**
   * If &lt;strong&gt;true&lt;/strong&gt;, disables stream targets when the transcoder starts. If &lt;strong&gt;false&lt;/strong&gt; (the default), the targets start when the transcoder starts.
   * @return suppressStreamTargetStart
  **/
  @ApiModelProperty(value = "If <strong>true</strong>, disables stream targets when the transcoder starts. If <strong>false</strong> (the default), the targets start when the transcoder starts.")
  public Boolean isSuppressStreamTargetStart() {
    return suppressStreamTargetStart;
  }

  public void setSuppressStreamTargetStart(Boolean suppressStreamTargetStart) {
    this.suppressStreamTargetStart = suppressStreamTargetStart;
  }

  public Transcoder transcoderType(TranscoderTypeEnum transcoderType) {
    this.transcoderType = transcoderType;
    return this;
  }

   /**
   * The type of transcoder, either &lt;strong&gt;transcoded&lt;/strong&gt; for streams that are transcoded into adaptive bitrate renditions or &lt;strong&gt;passthrough&lt;/strong&gt; for streams that aren&#39;t processed by the transcoder. The default is &lt;strong&gt;transcoded&lt;/strong&gt;.
   * @return transcoderType
  **/
  @ApiModelProperty(example = "", value = "The type of transcoder, either <strong>transcoded</strong> for streams that are transcoded into adaptive bitrate renditions or <strong>passthrough</strong> for streams that aren't processed by the transcoder. The default is <strong>transcoded</strong>.")
  public TranscoderTypeEnum getTranscoderType() {
    return transcoderType;
  }

  public void setTranscoderType(TranscoderTypeEnum transcoderType) {
    this.transcoderType = transcoderType;
  }

  public Transcoder updatedAt(OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
    return this;
  }

   /**
   * The date and time that the transcoder was updated.
   * @return updatedAt
  **/
  @ApiModelProperty(example = "", value = "The date and time that the transcoder was updated.")
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }

  public void setUpdatedAt(OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
  }

  public Transcoder username(String username) {
    this.username = username;
    return this;
  }

   /**
   * A username for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.
   * @return username
  **/
  @ApiModelProperty(example = "", value = "A username for authenticating an RTMP or RTSP push connection. Can contain only uppercase and lowercase letters; numbers; and the period (.), underscore (_), and hyphen (-) characters. No other special characters can be used.")
  public String getUsername() {
    return username;
  }

  public void setUsername(String username) {
    this.username = username;
  }

  public Transcoder watermark(Boolean watermark) {
    this.watermark = watermark;
    return this;
  }

   /**
   * Embeds an image into the transcoded stream for copyright protection. Specify &lt;strong&gt;true&lt;/strong&gt; to embed a watermark image.
   * @return watermark
  **/
  @ApiModelProperty(value = "Embeds an image into the transcoded stream for copyright protection. Specify <strong>true</strong> to embed a watermark image.")
  public Boolean isWatermark() {
    return watermark;
  }

  public void setWatermark(Boolean watermark) {
    this.watermark = watermark;
  }

  public Transcoder watermarkHeight(Integer watermarkHeight) {
    this.watermarkHeight = watermarkHeight;
    return this;
  }

   /**
   * The height, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image height.
   * @return watermarkHeight
  **/
  @ApiModelProperty(example = "", value = "The height, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image height.")
  public Integer getWatermarkHeight() {
    return watermarkHeight;
  }

  public void setWatermarkHeight(Integer watermarkHeight) {
    this.watermarkHeight = watermarkHeight;
  }

  public Transcoder watermarkImageUrl(String watermarkImageUrl) {
    this.watermarkImageUrl = watermarkImageUrl;
    return this;
  }

   /**
   * The path to a GIF, JPEG, or PNG image that is embedded in all bitrate renditions of the stream. Watermark image files must be 2.5 MB or smaller.
   * @return watermarkImageUrl
  **/
  @ApiModelProperty(example = "", value = "The path to a GIF, JPEG, or PNG image that is embedded in all bitrate renditions of the stream. Watermark image files must be 2.5 MB or smaller.")
  public String getWatermarkImageUrl() {
    return watermarkImageUrl;
  }

  public void setWatermarkImageUrl(String watermarkImageUrl) {
    this.watermarkImageUrl = watermarkImageUrl;
  }

  public Transcoder watermarkOpacity(WatermarkOpacityEnum watermarkOpacity) {
    this.watermarkOpacity = watermarkOpacity;
    return this;
  }

   /**
   * The opacity, or percentage of transparency, of the watermark. &lt;strong&gt;0&lt;/strong&gt; is fully transparent; &lt;strong&gt;100&lt;/strong&gt; is fully opaque.
   * @return watermarkOpacity
  **/
  @ApiModelProperty(example = "", value = "The opacity, or percentage of transparency, of the watermark. <strong>0</strong> is fully transparent; <strong>100</strong> is fully opaque.")
  public WatermarkOpacityEnum getWatermarkOpacity() {
    return watermarkOpacity;
  }

  public void setWatermarkOpacity(WatermarkOpacityEnum watermarkOpacity) {
    this.watermarkOpacity = watermarkOpacity;
  }

  public Transcoder watermarkPosition(WatermarkPositionEnum watermarkPosition) {
    this.watermarkPosition = watermarkPosition;
    return this;
  }

   /**
   * The corner of the video frame in which you want the watermark to appear. The default is &lt;strong&gt;top-left&lt;/strong&gt;.
   * @return watermarkPosition
  **/
  @ApiModelProperty(example = "", value = "The corner of the video frame in which you want the watermark to appear. The default is <strong>top-left</strong>.")
  public WatermarkPositionEnum getWatermarkPosition() {
    return watermarkPosition;
  }

  public void setWatermarkPosition(WatermarkPositionEnum watermarkPosition) {
    this.watermarkPosition = watermarkPosition;
  }

  public Transcoder watermarkWidth(Integer watermarkWidth) {
    this.watermarkWidth = watermarkWidth;
    return this;
  }

   /**
   * The width, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image width.
   * @return watermarkWidth
  **/
  @ApiModelProperty(example = "", value = "The width, in pixels, of the watermark image. If blank, Wowza Streaming Cloud uses the original image width.")
  public Integer getWatermarkWidth() {
    return watermarkWidth;
  }

  public void setWatermarkWidth(Integer watermarkWidth) {
    this.watermarkWidth = watermarkWidth;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Transcoder transcoder = (Transcoder) o;
    return Objects.equals(this.applicationName, transcoder.applicationName) &&
        Objects.equals(this.billingMode, transcoder.billingMode) &&
        Objects.equals(this.broadcastLocation, transcoder.broadcastLocation) &&
        Objects.equals(this.bufferSize, transcoder.bufferSize) &&
        Objects.equals(this.closedCaptionType, transcoder.closedCaptionType) &&
        Objects.equals(this.createdAt, transcoder.createdAt) &&
        Objects.equals(this.deliveryMethod, transcoder.deliveryMethod) &&
        Objects.equals(this.deliveryProtocols, transcoder.deliveryProtocols) &&
        Objects.equals(this.description, transcoder.description) &&
        Objects.equals(this.directPlaybackUrls, transcoder.directPlaybackUrls) &&
        Objects.equals(this.disableAuthentication, transcoder.disableAuthentication) &&
        Objects.equals(this.domainName, transcoder.domainName) &&
        Objects.equals(this.id, transcoder.id) &&
        Objects.equals(this.idleTimeout, transcoder.idleTimeout) &&
        Objects.equals(this.lowLatency, transcoder.lowLatency) &&
        Objects.equals(this.name, transcoder.name) &&
        Objects.equals(this.outputs, transcoder.outputs) &&
        Objects.equals(this.password, transcoder.password) &&
        Objects.equals(this.playMaximumConnections, transcoder.playMaximumConnections) &&
        Objects.equals(this.protocol, transcoder.protocol) &&
        Objects.equals(this.recording, transcoder.recording) &&
        Objects.equals(this.sourcePort, transcoder.sourcePort) &&
        Objects.equals(this.sourceUrl, transcoder.sourceUrl) &&
        Objects.equals(this.streamExtension, transcoder.streamExtension) &&
        Objects.equals(this.streamName, transcoder.streamName) &&
        Objects.equals(this.streamSmoother, transcoder.streamSmoother) &&
        Objects.equals(this.streamSourceId, transcoder.streamSourceId) &&
        Objects.equals(this.suppressStreamTargetStart, transcoder.suppressStreamTargetStart) &&
        Objects.equals(this.transcoderType, transcoder.transcoderType) &&
        Objects.equals(this.updatedAt, transcoder.updatedAt) &&
        Objects.equals(this.username, transcoder.username) &&
        Objects.equals(this.watermark, transcoder.watermark) &&
        Objects.equals(this.watermarkHeight, transcoder.watermarkHeight) &&
        Objects.equals(this.watermarkImageUrl, transcoder.watermarkImageUrl) &&
        Objects.equals(this.watermarkOpacity, transcoder.watermarkOpacity) &&
        Objects.equals(this.watermarkPosition, transcoder.watermarkPosition) &&
        Objects.equals(this.watermarkWidth, transcoder.watermarkWidth);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicationName, billingMode, broadcastLocation, bufferSize, closedCaptionType, createdAt, deliveryMethod, deliveryProtocols, description, directPlaybackUrls, disableAuthentication, domainName, id, idleTimeout, lowLatency, name, outputs, password, playMaximumConnections, protocol, recording, sourcePort, sourceUrl, streamExtension, streamName, streamSmoother, streamSourceId, suppressStreamTargetStart, transcoderType, updatedAt, username, watermark, watermarkHeight, watermarkImageUrl, watermarkOpacity, watermarkPosition, watermarkWidth);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Transcoder {\n");
    
    sb.append("    applicationName: ").append(toIndentedString(applicationName)).append("\n");
    sb.append("    billingMode: ").append(toIndentedString(billingMode)).append("\n");
    sb.append("    broadcastLocation: ").append(toIndentedString(broadcastLocation)).append("\n");
    sb.append("    bufferSize: ").append(toIndentedString(bufferSize)).append("\n");
    sb.append("    closedCaptionType: ").append(toIndentedString(closedCaptionType)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    deliveryMethod: ").append(toIndentedString(deliveryMethod)).append("\n");
    sb.append("    deliveryProtocols: ").append(toIndentedString(deliveryProtocols)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    directPlaybackUrls: ").append(toIndentedString(directPlaybackUrls)).append("\n");
    sb.append("    disableAuthentication: ").append(toIndentedString(disableAuthentication)).append("\n");
    sb.append("    domainName: ").append(toIndentedString(domainName)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    idleTimeout: ").append(toIndentedString(idleTimeout)).append("\n");
    sb.append("    lowLatency: ").append(toIndentedString(lowLatency)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    outputs: ").append(toIndentedString(outputs)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    playMaximumConnections: ").append(toIndentedString(playMaximumConnections)).append("\n");
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    recording: ").append(toIndentedString(recording)).append("\n");
    sb.append("    sourcePort: ").append(toIndentedString(sourcePort)).append("\n");
    sb.append("    sourceUrl: ").append(toIndentedString(sourceUrl)).append("\n");
    sb.append("    streamExtension: ").append(toIndentedString(streamExtension)).append("\n");
    sb.append("    streamName: ").append(toIndentedString(streamName)).append("\n");
    sb.append("    streamSmoother: ").append(toIndentedString(streamSmoother)).append("\n");
    sb.append("    streamSourceId: ").append(toIndentedString(streamSourceId)).append("\n");
    sb.append("    suppressStreamTargetStart: ").append(toIndentedString(suppressStreamTargetStart)).append("\n");
    sb.append("    transcoderType: ").append(toIndentedString(transcoderType)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    username: ").append(toIndentedString(username)).append("\n");
    sb.append("    watermark: ").append(toIndentedString(watermark)).append("\n");
    sb.append("    watermarkHeight: ").append(toIndentedString(watermarkHeight)).append("\n");
    sb.append("    watermarkImageUrl: ").append(toIndentedString(watermarkImageUrl)).append("\n");
    sb.append("    watermarkOpacity: ").append(toIndentedString(watermarkOpacity)).append("\n");
    sb.append("    watermarkPosition: ").append(toIndentedString(watermarkPosition)).append("\n");
    sb.append("    watermarkWidth: ").append(toIndentedString(watermarkWidth)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

