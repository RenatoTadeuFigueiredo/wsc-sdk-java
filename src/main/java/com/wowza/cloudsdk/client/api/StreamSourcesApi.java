/*
 * This code and all components Â© 2015 - 2019 Wowza Media Systems, LLC. All rights reserved.
 * This code is licensed pursuant to the BSD 3-Clause License.
 * 
 * Wowza Streaming Cloud REST API Reference Documentation
 *
 * OpenAPI spec version: v1.3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.wowza.cloudsdk.client.api;

import com.wowza.cloudsdk.client.ApiCallback;
import com.wowza.cloudsdk.client.ApiClient;
import com.wowza.cloudsdk.client.ApiException;
import com.wowza.cloudsdk.client.ApiResponse;
import com.wowza.cloudsdk.client.Configuration;
import com.wowza.cloudsdk.client.Pair;
import com.wowza.cloudsdk.client.ProgressRequestBody;
import com.wowza.cloudsdk.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import com.wowza.cloudsdk.client.model.AkamaiStreamSourceCreateInput;
import com.wowza.cloudsdk.client.model.StreamSourceAkamai;
import com.wowza.cloudsdk.client.model.StreamSource;
import com.wowza.cloudsdk.client.model.StreamSourceCreateInput;
import com.wowza.cloudsdk.client.model.StreamSourceCreateInput;
import com.wowza.cloudsdk.client.model.IndexStreamSource;
import com.wowza.cloudsdk.client.model.StreamSources;
import com.wowza.cloudsdk.client.model.StreamSourcesAkamai;
import com.wowza.cloudsdk.client.model.IndexAkamaiStreamSource;
import okhttp3.Call;
import okhttp3.Interceptor;
import okhttp3.Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class StreamSourcesApi {
    private ApiClient apiClient;

    public StreamSourcesApi() {
        this(Configuration.getDefaultApiClient());
    }

    public StreamSourcesApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for createStreamSource
     * @param streamSource Provide the details of the stream source to add in the body of the request. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call createStreamSourceCall(StreamSourceCreateInput streamSource, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = streamSource;

        // create path and map variables
        String localVarPath = "/stream_sources ";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call createStreamSourceValidateBeforeCall(StreamSourceCreateInput streamSource, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'streamSource' is set
        if (streamSource == null) {
            throw new ApiException("Missing the required parameter 'streamSource' when calling createStreamSource(Async)");
        }
        

        Call call = createStreamSourceCall(streamSource, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Deprecated operation
     * &lt;em&gt;POST /stream_sources&lt;/em&gt; is deprecated. To add a stream source, use &lt;em&gt;POST /stream_sources/akamai&lt;/em&gt; instead.
     * @param streamSource Provide the details of the stream source to add in the body of the request. (required)
     * @return StreamSource
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StreamSource createStreamSource(StreamSourceCreateInput streamSource) throws ApiException {
        ApiResponse<StreamSource> resp = createStreamSourceWithHttpInfo(streamSource);
        return resp.getData();
    }

    /**
     * Deprecated operation
     * &lt;em&gt;POST /stream_sources&lt;/em&gt; is deprecated. To add a stream source, use &lt;em&gt;POST /stream_sources/akamai&lt;/em&gt; instead.
     * @param streamSource Provide the details of the stream source to add in the body of the request. (required)
     * @return ApiResponse&lt;StreamSource&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StreamSource> createStreamSourceWithHttpInfo(StreamSourceCreateInput streamSource) throws ApiException {
        Call call = createStreamSourceValidateBeforeCall(streamSource, null, null);
        Type localVarReturnType = new TypeToken<StreamSource>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Deprecated operation (asynchronously)
     * &lt;em&gt;POST /stream_sources&lt;/em&gt; is deprecated. To add a stream source, use &lt;em&gt;POST /stream_sources/akamai&lt;/em&gt; instead.
     * @param streamSource Provide the details of the stream source to add in the body of the request. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call createStreamSourceAsync(StreamSourceCreateInput streamSource, final ApiCallback<StreamSource> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = createStreamSourceValidateBeforeCall(streamSource, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StreamSource>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for createakamaiStreamSource
     * @param streamSourceAkamai Provide the details of the stream source to add in the body of the request.&lt;/blockquote&gt; (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call createakamaiStreamSourceCall(AkamaiStreamSourceCreateInput streamSourceAkamai, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = streamSourceAkamai;

        // create path and map variables
        String localVarPath = "/stream_sources/akamai";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call createakamaiStreamSourceValidateBeforeCall(AkamaiStreamSourceCreateInput streamSourceAkamai, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'streamSourceAkamai' is set
        if (streamSourceAkamai == null) {
            throw new ApiException("Missing the required parameter 'streamSourceAkamai' when calling createakamaiStreamSource(Async)");
        }
        

        Call call = createakamaiStreamSourceCall(streamSourceAkamai, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Create an Akamai stream source
     * (Available from version 1.3) This operation creates an Akamai stream source.  An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol. &lt;br /&gt;&lt;br /&gt;&lt;blockquote&gt;**Note:** An Akamai stream source with a *location_method* of **ip_address** requires provisioning time of 15 to 45 minutes. Values for *backup_url*, *primary_url*, *username*, and *password* are available once the stream source is provisioned. We recommend sending GET requests to query for the Akamai stream source no less than five seconds apart.
     * @param streamSourceAkamai Provide the details of the stream source to add in the body of the request.&lt;/blockquote&gt; (required)
     * @return StreamSourceAkamai
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StreamSourceAkamai createAkamaiStreamSource(StreamSourceAkamai streamSourceAkamai) throws ApiException {
	AkamaiStreamSourceCreateInput akamaiCreateInput = new AkamaiStreamSourceCreateInput();
	akamaiCreateInput.setStreamSourceAkamai(streamSourceAkamai);
        AkamaiStreamSourceCreateInput resp = createakamaiStreamSourceTransport(akamaiCreateInput);
        return resp.getStreamSourceAkamai();
    }

    /**
     * Create an Akamai stream source - Transport Wrapped
     * (Available from version 1.3) This operation creates an Akamai stream source.  An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol. &lt;br /&gt;&lt;br /&gt;&lt;blockquote&gt;**Note:** An Akamai stream source with a *location_method* of **ip_address** requires provisioning time of 15 to 45 minutes. Values for *backup_url*, *primary_url*, *username*, and *password* are available once the stream source is provisioned. We recommend sending GET requests to query for the Akamai stream source no less than five seconds apart.
     * @param streamSourceAkamai Provide the details of the stream source to add in the body of the request.&lt;/blockquote&gt; (required)
     * @return AkamaiStreamSourceCreateInput
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public AkamaiStreamSourceCreateInput createakamaiStreamSourceTransport(AkamaiStreamSourceCreateInput streamSourceAkamai) throws ApiException {
        ApiResponse<AkamaiStreamSourceCreateInput> resp = createakamaiStreamSourceWithHttpInfo(streamSourceAkamai);
        return resp.getData();
    }

    /**
     * Create an Akamai stream source
     * (Available from version 1.3) This operation creates an Akamai stream source.  An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol. &lt;br /&gt;&lt;br /&gt;&lt;blockquote&gt;**Note:** An Akamai stream source with a *location_method* of **ip_address** requires provisioning time of 15 to 45 minutes. Values for *backup_url*, *primary_url*, *username*, and *password* are available once the stream source is provisioned. We recommend sending GET requests to query for the Akamai stream source no less than five seconds apart.
     * @param streamSourceAkamai Provide the details of the stream source to add in the body of the request.&lt;/blockquote&gt; (required)
     * @return ApiResponse&lt;AkamaiStreamSourceCreateInput&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<AkamaiStreamSourceCreateInput> createakamaiStreamSourceWithHttpInfo(AkamaiStreamSourceCreateInput streamSourceAkamai) throws ApiException {
        Call call = createakamaiStreamSourceValidateBeforeCall(streamSourceAkamai, null, null);
        Type localVarReturnType = new TypeToken<AkamaiStreamSourceCreateInput>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Create an Akamai stream source (asynchronously)
     * (Available from version 1.3) This operation creates an Akamai stream source.  An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol. &lt;br /&gt;&lt;br /&gt;&lt;blockquote&gt;**Note:** An Akamai stream source with a *location_method* of **ip_address** requires provisioning time of 15 to 45 minutes. Values for *backup_url*, *primary_url*, *username*, and *password* are available once the stream source is provisioned. We recommend sending GET requests to query for the Akamai stream source no less than five seconds apart.
     * @param streamSourceAkamai Provide the details of the stream source to add in the body of the request.&lt;/blockquote&gt; (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call createakamaiStreamSourceAsync(AkamaiStreamSourceCreateInput streamSourceAkamai, final ApiCallback<AkamaiStreamSourceCreateInput> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = createakamaiStreamSourceValidateBeforeCall(streamSourceAkamai, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<AkamaiStreamSourceCreateInput>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for deleteStreamSource
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call deleteStreamSourceCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/stream_sources/{id}"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call deleteStreamSourceValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteStreamSource(Async)");
        }
        

        Call call = deleteStreamSourceCall(id, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Deprecated operation
     * &lt;em&gt;DELETE /stream_sources/[id]&lt;/em&gt; is deprecated. To delete a stream source, use &lt;em&gt;DELETE /stream_sources/akamai/[id]&lt;/em&gt; instead.
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void deleteStreamSource(String id) throws ApiException {
        deleteStreamSourceWithHttpInfo(id);
    }

    /**
     * Deprecated operation
     * &lt;em&gt;DELETE /stream_sources/[id]&lt;/em&gt; is deprecated. To delete a stream source, use &lt;em&gt;DELETE /stream_sources/akamai/[id]&lt;/em&gt; instead.
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> deleteStreamSourceWithHttpInfo(String id) throws ApiException {
        Call call = deleteStreamSourceValidateBeforeCall(id, null, null);
        return apiClient.execute(call);
    }

    /**
     * Deprecated operation (asynchronously)
     * &lt;em&gt;DELETE /stream_sources/[id]&lt;/em&gt; is deprecated. To delete a stream source, use &lt;em&gt;DELETE /stream_sources/akamai/[id]&lt;/em&gt; instead.
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call deleteStreamSourceAsync(String id, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = deleteStreamSourceValidateBeforeCall(id, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for deleteakamaiStreamSource
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call deleteakamaiStreamSourceCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/stream_sources/akamai/{id}"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call deleteakamaiStreamSourceValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteakamaiStreamSource(Async)");
        }
        

        Call call = deleteakamaiStreamSourceCall(id, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Delete an Akamai stream source
     * (Available from version 1.3) This operation deletes an Akamai stream source.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void deleteAkamaiStreamSource(String id) throws ApiException {
        deleteakamaiStreamSourceWithHttpInfo(id);
    }

    /**
     * Delete an Akamai stream source
     * (Available from version 1.3) This operation deletes an Akamai stream source.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> deleteakamaiStreamSourceWithHttpInfo(String id) throws ApiException {
        Call call = deleteakamaiStreamSourceValidateBeforeCall(id, null, null);
        return apiClient.execute(call);
    }

    /**
     * Delete an Akamai stream source (asynchronously)
     * (Available from version 1.3) This operation deletes an Akamai stream source.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call deleteakamaiStreamSourceAsync(String id, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = deleteakamaiStreamSourceValidateBeforeCall(id, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for listAkamaiStreamSources
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call listAkamaiStreamSourcesCall(Integer page, Integer perPage, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/stream_sources/akamai";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (perPage != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("per_page", perPage));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call listAkamaiStreamSourcesValidateBeforeCall(Integer page, Integer perPage, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        Call call = listAkamaiStreamSourcesCall(page, perPage, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Fetch all Akamai stream sources
     * (Available from version 1.3) This operation shows limited details for all of your Akamai stream sources. An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol. For detailed information, fetch a single Akamai stream source.
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @return List
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<IndexAkamaiStreamSource> listAkamaiStreamSources(Integer page, Integer perPage) throws ApiException {
        StreamSourcesAkamai resp = listAkamaiStreamSourcesTransport(page, perPage);
        return resp.getStreamSourcesAkamai();
    }

    /**
     * Fetch all Akamai stream sources - Transport Wrapped 
     * (Available from version 1.3) This operation shows limited details for all of your Akamai stream sources. An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol. For detailed information, fetch a single Akamai stream source.
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @return StreamSourcesAkamai
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StreamSourcesAkamai listAkamaiStreamSourcesTransport(Integer page, Integer perPage) throws ApiException {
        ApiResponse<StreamSourcesAkamai> resp = listAkamaiStreamSourcesWithHttpInfo(page, perPage);
        return resp.getData();
    }

    /**
     * Fetch all Akamai stream sources
     * (Available from version 1.3) This operation shows limited details for all of your Akamai stream sources. An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol. For detailed information, fetch a single Akamai stream source.
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @return ApiResponse&lt;StreamSourcesAkamai&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StreamSourcesAkamai> listAkamaiStreamSourcesWithHttpInfo(Integer page, Integer perPage) throws ApiException {
        Call call = listAkamaiStreamSourcesValidateBeforeCall(page, perPage, null, null);
        Type localVarReturnType = new TypeToken<StreamSourcesAkamai>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Fetch all Akamai stream sources (asynchronously)
     * (Available from version 1.3) This operation shows limited details for all of your Akamai stream sources. An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol. For detailed information, fetch a single Akamai stream source.
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call listAkamaiStreamSourcesAsync(Integer page, Integer perPage, final ApiCallback<StreamSourcesAkamai> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = listAkamaiStreamSourcesValidateBeforeCall(page, perPage, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StreamSourcesAkamai>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for listStreamSources
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call listStreamSourcesCall(Integer page, Integer perPage, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/stream_sources";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (page != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("page", page));
        if (perPage != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("per_page", perPage));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call listStreamSourcesValidateBeforeCall(Integer page, Integer perPage, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        Call call = listStreamSourcesCall(page, perPage, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Fetch all stream sources
     * This operation shows limited details for all of your stream sources. For detailed information, fetch a single stream source of the appropriate type.
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @return List
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public List<IndexStreamSource> listStreamSources(Integer page, Integer perPage) throws ApiException {
        StreamSources resp = listStreamSourcesTransport(page, perPage);
        return resp.getStreamSources();
    }

    /**
     * Fetch all stream sources - Transport Wrapped 
     * This operation shows limited details for all of your stream sources. For detailed information, fetch a single stream source of the appropriate type.
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @return StreamSources
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StreamSources listStreamSourcesTransport(Integer page, Integer perPage) throws ApiException {
        ApiResponse<StreamSources> resp = listStreamSourcesWithHttpInfo(page, perPage);
        return resp.getData();
    }

    /**
     * Fetch all stream sources
     * This operation shows limited details for all of your stream sources. For detailed information, fetch a single stream source of the appropriate type.
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @return ApiResponse&lt;StreamSources&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StreamSources> listStreamSourcesWithHttpInfo(Integer page, Integer perPage) throws ApiException {
        Call call = listStreamSourcesValidateBeforeCall(page, perPage, null, null);
        Type localVarReturnType = new TypeToken<StreamSources>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Fetch all stream sources (asynchronously)
     * This operation shows limited details for all of your stream sources. For detailed information, fetch a single stream source of the appropriate type.
     * @param page Returns a paginated view of results from the HTTP request. Specify a positive integer to indicate which page of the results should be displayed. The default is &lt;strong&gt;1&lt;/strong&gt;.&lt;br /&gt;&lt;br /&gt;For more information and examples, see &lt;a href&#x3D;&#39;https://www.wowza.com/docs/how-to-get-paginated-query-results-with-the-wowza-streaming-cloud-rest-api&#39; target&#x3D;&#39;_blank&#39;&gt;Get paginated query results with the Wowza Streaming Cloud REST API&lt;/a&gt;. (optional)
     * @param perPage For use with the &lt;em&gt;page&lt;/em&gt; parameter. Indicates how many records should be included in a page of results. A valid value is any positive integer. The default and maximum value is &lt;strong&gt;1000&lt;/strong&gt;. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call listStreamSourcesAsync(Integer page, Integer perPage, final ApiCallback<StreamSources> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = listStreamSourcesValidateBeforeCall(page, perPage, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StreamSources>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for showAkamaiStreamSource
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call showAkamaiStreamSourceCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/stream_sources/akamai/{id}"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call showAkamaiStreamSourceValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling showAkamaiStreamSource(Async)");
        }
        

        Call call = showAkamaiStreamSourceCall(id, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Fetch an Akamai stream source
     * (Available from version 1.3) This operation shows details of a specific Akamai stream source.  An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @return StreamSourceAkamai
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StreamSourceAkamai showAkamaiStreamSource(String id) throws ApiException {
 	AkamaiStreamSourceCreateInput resp = showAkamaiStreamSourceTransport(id);
        return resp.getStreamSourceAkamai();
    }

    /**
     * Fetch an Akamai stream source - Transport Wrapped
     * (Available from version 1.3) This operation shows details of a specific Akamai stream source.  An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @return AkamaiStreamSourceCreateInput
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public AkamaiStreamSourceCreateInput showAkamaiStreamSourceTransport(String id) throws ApiException {
        ApiResponse<AkamaiStreamSourceCreateInput> resp = showAkamaiStreamSourceWithHttpInfo(id);
        return resp.getData();
    }

    /**
     * Fetch an Akamai stream source
     * (Available from version 1.3) This operation shows details of a specific Akamai stream source.  An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @return ApiResponse&lt;AkamaiStreamSourceCreateInput&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<AkamaiStreamSourceCreateInput> showAkamaiStreamSourceWithHttpInfo(String id) throws ApiException {
        Call call = showAkamaiStreamSourceValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<AkamaiStreamSourceCreateInput>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Fetch an Akamai stream source (asynchronously)
     * (Available from version 1.3) This operation shows details of a specific Akamai stream source.  An Akamai stream source is an edge resource that sends a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call showAkamaiStreamSourceAsync(String id, final ApiCallback<AkamaiStreamSourceCreateInput> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = showAkamaiStreamSourceValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<AkamaiStreamSourceCreateInput>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for showStreamSource
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call showStreamSourceCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/stream_sources/{id}"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call showStreamSourceValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling showStreamSource(Async)");
        }
        

        Call call = showStreamSourceCall(id, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Deprecated operation
     * &lt;em&gt;GET /stream_sources/[id]&lt;/em&gt; is deprecated. To retrieve a single stream source, use &lt;em&gt;GET /stream_sources/akamai/[id]&lt;/em&gt; instead.
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @return StreamSource
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StreamSource showStreamSource(String id) throws ApiException {
        ApiResponse<StreamSource> resp = showStreamSourceWithHttpInfo(id);
        return resp.getData();
    }

    /**
     * Deprecated operation
     * &lt;em&gt;GET /stream_sources/[id]&lt;/em&gt; is deprecated. To retrieve a single stream source, use &lt;em&gt;GET /stream_sources/akamai/[id]&lt;/em&gt; instead.
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @return ApiResponse&lt;StreamSource&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StreamSource> showStreamSourceWithHttpInfo(String id) throws ApiException {
        Call call = showStreamSourceValidateBeforeCall(id, null, null);
        Type localVarReturnType = new TypeToken<StreamSource>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Deprecated operation (asynchronously)
     * &lt;em&gt;GET /stream_sources/[id]&lt;/em&gt; is deprecated. To retrieve a single stream source, use &lt;em&gt;GET /stream_sources/akamai/[id]&lt;/em&gt; instead.
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call showStreamSourceAsync(String id, final ApiCallback<StreamSource> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = showStreamSourceValidateBeforeCall(id, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StreamSource>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateAkamaiStreamSource
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @param streamSourceAkamai Provide the details of the stream source to update in the body of the request. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call updateAkamaiStreamSourceCall(String id, AkamaiStreamSourceCreateInput streamSourceAkamai, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = streamSourceAkamai;

        // create path and map variables
        String localVarPath = "/stream_sources/akamai/{id}"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call updateAkamaiStreamSourceValidateBeforeCall(String id, AkamaiStreamSourceCreateInput streamSourceAkamai, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling updateAkamaiStreamSource(Async)");
        }
        
        // verify the required parameter 'streamSourceAkamai' is set
        if (streamSourceAkamai == null) {
            throw new ApiException("Missing the required parameter 'streamSourceAkamai' when calling updateAkamaiStreamSource(Async)");
        }
        

        Call call = updateAkamaiStreamSourceCall(id, streamSourceAkamai, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Update an Akamai stream source
     * (Available from version 1.3) This operation updates an Akamai stream source.  An Akamai stream source is an edge resource that send a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @param streamSourceAkamai Provide the details of the stream source to update in the body of the request. (required)
     * @return StreamSourceAkamai
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StreamSourceAkamai updateAkamaiStreamSource(String id, StreamSourceAkamai streamSourceAkamai) throws ApiException {
	AkamaiStreamSourceCreateInput akamaiInput = new AkamaiStreamSourceCreateInput();
	akamaiInput.setStreamSourceAkamai(streamSourceAkamai);
        AkamaiStreamSourceCreateInput resp = updateAkamaiStreamSourceTransport(id, akamaiInput);
        return resp.getStreamSourceAkamai();
    }

    /**
     * Update an Akamai stream source - Transport Wrapped
     * (Available from version 1.3) This operation updates an Akamai stream source.  An Akamai stream source is an edge resource that send a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @param streamSourceAkamai Provide the details of the stream source to update in the body of the request. (required)
     * @return AkamaiStreamSourceCreateInput
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public AkamaiStreamSourceCreateInput updateAkamaiStreamSourceTransport(String id, AkamaiStreamSourceCreateInput streamSourceAkamai) throws ApiException {
        ApiResponse<AkamaiStreamSourceCreateInput> resp = updateAkamaiStreamSourceWithHttpInfo(id, streamSourceAkamai);
        return resp.getData();
    }

    /**
     * Update an Akamai stream source
     * (Available from version 1.3) This operation updates an Akamai stream source.  An Akamai stream source is an edge resource that send a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @param streamSourceAkamai Provide the details of the stream source to update in the body of the request. (required)
     * @return ApiResponse&lt;AkamaiStreamSourceCreateInput&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<AkamaiStreamSourceCreateInput> updateAkamaiStreamSourceWithHttpInfo(String id, AkamaiStreamSourceCreateInput streamSourceAkamai) throws ApiException {
        Call call = updateAkamaiStreamSourceValidateBeforeCall(id, streamSourceAkamai, null, null);
        Type localVarReturnType = new TypeToken<AkamaiStreamSourceCreateInput>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Update an Akamai stream source (asynchronously)
     * (Available from version 1.3) This operation updates an Akamai stream source.  An Akamai stream source is an edge resource that send a stream to a Wowza Streaming Cloud transcoder using the RTMP protocol.
     * @param id The unique alphanumeric string that identifies the Akamai stream source. (required)
     * @param streamSourceAkamai Provide the details of the stream source to update in the body of the request. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call updateAkamaiStreamSourceAsync(String id, AkamaiStreamSourceCreateInput streamSourceAkamai, final ApiCallback<AkamaiStreamSourceCreateInput> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = updateAkamaiStreamSourceValidateBeforeCall(id, streamSourceAkamai, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<AkamaiStreamSourceCreateInput>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for updateStreamSource
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @param streamSource Provide the details of the stream source to update in the body of the request. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public Call updateStreamSourceCall(String id, StreamSourceCreateInput streamSource, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = streamSource;

        // create path and map variables
        String localVarPath = "/stream_sources/{id}"
            .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new Interceptor() {
                @Override
                public Response intercept(Interceptor.Chain chain) throws IOException {
                    Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "wsc-access-key", "wsc-api-key", "wsc-signature", "wsc-timestamp" };
        return apiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private Call updateStreamSourceValidateBeforeCall(String id, StreamSourceCreateInput streamSource, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling updateStreamSource(Async)");
        }
        
        // verify the required parameter 'streamSource' is set
        if (streamSource == null) {
            throw new ApiException("Missing the required parameter 'streamSource' when calling updateStreamSource(Async)");
        }
        

        Call call = updateStreamSourceCall(id, streamSource, progressListener, progressRequestListener);
        return call;

    }

    /**
     * Deprecated operation
     * &lt;em&gt;PATCH /stream_sources/[id]&lt;/em&gt; is deprecated. To update a stream source, use &lt;em&gt;PATCH /stream_sources/akamai/[id]&lt;/em&gt; instead.
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @param streamSource Provide the details of the stream source to update in the body of the request. (required)
     * @return StreamSource
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public StreamSource updateStreamSource(String id, StreamSourceCreateInput streamSource) throws ApiException {
        ApiResponse<StreamSource> resp = updateStreamSourceWithHttpInfo(id, streamSource);
        return resp.getData();
    }

    /**
     * Deprecated operation
     * &lt;em&gt;PATCH /stream_sources/[id]&lt;/em&gt; is deprecated. To update a stream source, use &lt;em&gt;PATCH /stream_sources/akamai/[id]&lt;/em&gt; instead.
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @param streamSource Provide the details of the stream source to update in the body of the request. (required)
     * @return ApiResponse&lt;StreamSource&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<StreamSource> updateStreamSourceWithHttpInfo(String id, StreamSourceCreateInput streamSource) throws ApiException {
        Call call = updateStreamSourceValidateBeforeCall(id, streamSource, null, null);
        Type localVarReturnType = new TypeToken<StreamSource>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Deprecated operation (asynchronously)
     * &lt;em&gt;PATCH /stream_sources/[id]&lt;/em&gt; is deprecated. To update a stream source, use &lt;em&gt;PATCH /stream_sources/akamai/[id]&lt;/em&gt; instead.
     * @param id The unique alphanumeric string that identifies the stream source. (required)
     * @param streamSource Provide the details of the stream source to update in the body of the request. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public Call updateStreamSourceAsync(String id, StreamSourceCreateInput streamSource, final ApiCallback<StreamSource> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        Call call = updateStreamSourceValidateBeforeCall(id, streamSource, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<StreamSource>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
